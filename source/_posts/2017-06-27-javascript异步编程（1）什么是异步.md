---
title: javascript异步编程（1）什么是异步
date: 2017-06-27 22:53:17
categories:
- 技术
- Javascript
tags:
- Javascript
- 异步编程
---

# 开发中常见的异步操作
* 网络请求，如`ajax` `http.get`
* IO 操作，如`readFile` `readdir`
* 定时函数，如`setTimeout` `setInterval`

 <!-- more -->

# 同步vs异步

**同步**：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。

例如：
```javascript
Math.sqrt(2);
console.log('Hi');

```
**异步**：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。  

例如：
```javascript
fs.readFile('foo.txt', 'utf8', function(err, data) {
    console.log(data);
});
```
正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。

> 我们常说“**JavaScript是单线程的**”。
>
> 所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它**主线程**。
>
> 但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们**工作线程**

# 异步过程的构成要素
从上文可以看出，**异步函数**实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做**异步过程**。异步函数的调用在整个异步过程中，只是一小部分。 

总结一下，一个异步过程通常是这样的：

> 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。  

异步函数通常具有以下的形式：

```javascript
A(args..., callbackFn)
```
它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。args是这个函数需要的参数。callbackFn也是这个函数的参数，但是它比较特殊所以单独列出来。

所以，从主线程的角度看，一个异步过程包括下面两个要素：

* 发起函数(或叫注册函数)A
* 回调函数callbackFn  

它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。

# 消息队列和事件循环

上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个**通知机制**是怎样实现的呢？答案是利用消息队列和事件循环。

用一句话概括：

>工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。

* **消息队列（task queue）**：消息队列是一个先进先出的队列，它里面存放着各种消息。
* **事件循环（Event Loop）**：事件循环是指主线程重复从消息队列中取消息、执行的过程。

实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做**事件循环机制**，取一个消息并执行的过程叫做一次循环。

主线程和任务队列示意图：
![](/images/javascript/js-task-queue.jpg)


那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为

> 消息就是注册异步任务时添加的回调函数。 

再次以异步AJAX为例，假设存在如下的代码：
```javascript
$.ajax('http://segmentfault.com', function(resp) {
    console.log('我是响应：', resp);
});

// 其他代码
...
...
...
```
用图表示这个过程就是：
![](/images/javascript/js-ajax-process.png)

从上文中我们也可以得到这样一个明显的结论，就是：

> 异步过程的回调函数，一定不在当前这一轮事件循环中执行。

# 异步与事件
上文中说的“事件循环”，为什么里面有个**事件**呢？那是因为：

> 消息队列中的每条消息实际上都对应着一个事件。

上文中一直没有提到一类很重要的异步过程：**DOM事件**。

举例来说：
```javascript
var button = document.getElement('#btn');
button.addEventListener('click', function(e) {
    console.log();
});
```
从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。  

从异步过程的角度看，`addEventListener`函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。

# 生产者与消费者

从生产者与消费者的角度看，异步过程是这样的：

> 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。

# 参考链接
- [segmentfault——JavaScript：彻底理解同步、异步和事件循环(Event Loop)](https://segmentfault.com/a/1190000004322358)
- [一波——JavaScript 异步编程学习笔记](https://github.com/riskers/blog/issues/22)
- [王福朋的深入理解 JavaScript 异步](https://github.com/wangfupeng1988/js-async-tutorial)
